// <copyright file="ConnectionManager.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (publish/rebuild the
//     managed library project).
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable RedundantVerbatimPrefix
// ReSharper disable AssignmentIsFullyDiscarded
// ReSharper disable UnusedMember.Global
// ReSharper disable UseObjectOrCollectionInitializer

#nullable enable
namespace MUnique.Client.ManagedLibrary;

using System;
using System.Runtime.InteropServices;

using MUnique.OpenMU.Network;
using MUnique.OpenMU.Network.Packets;
using MUnique.OpenMU.Network.Packets.ConnectServer;

/// <summary>
/// Extension methods to start writing messages of this namespace on a <see cref="IConnection"/>.
/// </summary>
public unsafe partial class ConnectionManager
{

    /// <summary>
    /// Sends a <see cref="ConnectionInfoRequest075" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="serverId">The server id.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client after the user clicked on an entry of the server list.
    /// Causes reaction on server side: The server will send a ConnectionInfo back to the client.
    /// </remarks>
    [UnmanagedCallersOnly]
    public static void SendConnectionInfoRequest075(int handle, byte @serverId)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            var length = ConnectionInfoRequest075Ref.Length;
            var packet = new ConnectionInfoRequest075Ref(connection.Output.GetSpan(length)[..length]);
            packet.ServerId = @serverId;

            connection.Send(packet);
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="ConnectionInfoRequest" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="serverId">The server id.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client after the user clicked on an entry of the server list.
    /// Causes reaction on server side: The server will send a ConnectionInfo back to the client.
    /// </remarks>
    [UnmanagedCallersOnly]
    public static void SendConnectionInfoRequest(int handle, ushort @serverId)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            var length = ConnectionInfoRequestRef.Length;
            var packet = new ConnectionInfoRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.ServerId = @serverId;

            connection.Send(packet);
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="ConnectionInfo" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="ipAddress">The ip address.</param>
    /// <param name="ipAddressByteLength">The length of <paramref name="ipAddress"/>.</param>
    /// <param name="port">The port.</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after the client requested the connection information of a server. This happens after the user clicked on a server.
    /// Causes reaction on client side: The client will try to connect to the server with the specified information.
    /// </remarks>
    [UnmanagedCallersOnly]
    public static void SendConnectionInfo(int handle, IntPtr @ipAddress, uint ipAddressByteLength, ushort @port)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            var length = ConnectionInfoRef.Length;
            var packet = new ConnectionInfoRef(connection.Output.GetSpan(length)[..length]);
            packet.IpAddress = Marshal.PtrToStringAnsi(@ipAddress, (int)ipAddressByteLength);
            packet.Port = @port;

            connection.Send(packet);
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="ServerListRequest" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client after it connected and received the 'Hello' message.
    /// Causes reaction on server side: The server will send a ServerListResponse back to the client.
    /// </remarks>
    [UnmanagedCallersOnly]
    public static void SendServerListRequest(int handle)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            var length = ServerListRequestRef.Length;
            var packet = new ServerListRequestRef(connection.Output.GetSpan(length)[..length]);
            connection.Send(packet);
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="ServerListRequestOld" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client (below season 1) after it connected and received the 'Hello' message.
    /// Causes reaction on server side: The server will send a ServerListResponseOld back to the client.
    /// </remarks>
    [UnmanagedCallersOnly]
    public static void SendServerListRequestOld(int handle)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            var length = ServerListRequestOldRef.Length;
            var packet = new ServerListRequestOldRef(connection.Output.GetSpan(length)[..length]);
            connection.Send(packet);
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="Hello" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after the client connected to the server.
    /// Causes reaction on client side: A game client will request the server list. The launcher would request the patch state.
    /// </remarks>
    [UnmanagedCallersOnly]
    public static void SendHello(int handle)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            var length = HelloRef.Length;
            var packet = new HelloRef(connection.Output.GetSpan(length)[..length]);
            connection.Send(packet);
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="PatchCheckRequest" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="majorVersion">The major version.</param>
    /// <param name="minorVersion">The minor version.</param>
    /// <param name="patchVersion">The patch version.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client (launcher) to check if the patch version is high enough to be able to connect to the server.
    /// Causes reaction on server side: The connect server will check the version and sends a 'PatchVersionOkay' or a 'ClientNeedsPatch' message.
    /// </remarks>
    [UnmanagedCallersOnly]
    public static void SendPatchCheckRequest(int handle, byte @majorVersion, byte @minorVersion, byte @patchVersion)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            var length = PatchCheckRequestRef.Length;
            var packet = new PatchCheckRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.MajorVersion = @majorVersion;
            packet.MinorVersion = @minorVersion;
            packet.PatchVersion = @patchVersion;

            connection.Send(packet);
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="PatchVersionOkay" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after the client (launcher) requested the to check the patch version and it was high enough.
    /// Causes reaction on client side: The launcher will activate its start button.
    /// </remarks>
    [UnmanagedCallersOnly]
    public static void SendPatchVersionOkay(int handle)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            var length = PatchVersionOkayRef.Length;
            var packet = new PatchVersionOkayRef(connection.Output.GetSpan(length)[..length]);
            connection.Send(packet);
        }
        catch
        {
            // Log exception
        }
    }

    /// <summary>
    /// Sends a <see cref="ClientNeedsPatch" /> to this connection.
    /// </summary>
    /// <param name="handle">The handle of the connection.</param>
    /// <param name="patchVersion">The patch version.</param>
    /// <param name="patchAddress">The patch address, usually to a ftp server. The address is usually "encrypted" with the 3-byte XOR key (FC CF AB).</param>
    /// <param name="patchAddressByteLength">The length of <paramref name="patchAddress"/>.</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after the client (launcher) requested to check the patch version and it requires an update.
    /// Causes reaction on client side: The launcher will download the required patches and then activate the start button.
    /// </remarks>
    [UnmanagedCallersOnly]
    public static void SendClientNeedsPatch(int handle, byte @patchVersion, IntPtr @patchAddress, uint patchAddressByteLength)
    {
        if (!Connections.TryGetValue(handle, out var connection))
        {
            return;
        }

        try
        {
            var length = ClientNeedsPatchRef.Length;
            var packet = new ClientNeedsPatchRef(connection.Output.GetSpan(length)[..length]);
            packet.PatchVersion = @patchVersion;
            packet.PatchAddress = Marshal.PtrToStringAnsi(@patchAddress, (int)patchAddressByteLength);

            connection.Send(packet);
        }
        catch
        {
            // Log exception
        }
    }}